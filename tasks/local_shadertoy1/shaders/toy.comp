#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8)  uniform image2D resultImage;
layout(push_constant)       uniform Parameters {
  // GLSL has uints.
  //   https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Scalars
  uint iResolution_x;
  uint iResolution_y;
  float time;
} parameters;

float iTime;
vec2  iResolution;

const vec3  eye      = vec3 ( 0, 0, 5 );
const vec3  light    = vec3  ( 0.0, 3.0, 5.0 );
const int   maxSteps = 70;
const float eps      = 0.01;
const float pi    = 3.1415926;

const vec3  cupClr  = vec3 ( 1, 0.3, 0 );
const vec3 soupClr = vec3(0.6, 0.2, 0);

// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

// Rotation matrix around the Z axis.
mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, s, 0),
        vec3(-s, c, 0),
        vec3(0, 0, 1)
    );
}


float smin ( float a, float b, float k )
{
	float res = exp ( -k*a ) + exp ( -k*b );
	return -log ( res ) / k;
}

float sdCutSphere( vec3 p, float r, float h )
{
  // sampling independent computations (only depend on shape)
  float w = sqrt(r*r-h*h);

  // sampling dependant computations
  vec2 q = vec2( length(p.xz), p.y );
  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );
  return (s<0.0) ? length(q)-r :
         (q.x<w) ? h - q.y     :
                   length(q-vec2(w,h));
}

// Функция не работает...
float sdDiff(float srcdist, float subdist) {
    // Представим себе летящий луч, пересекающий фигуры.
    // -->->- src ->D>- sub
    //   Норм, возвращаем src.
    // -->->- src = sub
    //   Не понятно :( :( :( Не понятно, беру с лекции.
    // -->->- sub ->D>- dst
    //   Возвращаем dst.
    // Ограничение -- вся фигура sub лежит в src,
    //   т.к. мы продвигаемся по лучу до окончания фигуры
  
   return max(-subdist, srcdist);
}
/*
float sdf ( in vec3 p, in mat3 m )
{
   vec3 q = m * p;
   
   float base = sdDiff(sdCutSphere(q, 1.0, -1.0), sdCutSphere(q, 1.0, 0.3));
   float inner = sdCutSphere(q, 0.9, -0.9);
   float result = sdDiff(base, inner);
   return sdCutSphere(q, 1.0, 0.3);
}
*/


float sdCutHollowSphere( vec3 p, float r, float h, float t )
{
  // sampling independent computations (only depend on shape)
  float w = sqrt(r*r-h*h);
  
  // sampling dependant computations
  vec2 q = vec2( length(p.xz), p.y );
  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : 
                          abs(length(q)-r) ) - t;
}

float sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)
{
  p.x = abs(p.x);
  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

float sdf ( in vec3 p, in mat3 m, out vec3 clr )
{
   //m = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
   vec3 realpnt = m * p;
   float base = sdCutHollowSphere(realpnt, 1.0, 0.4, 0.1);
   
   float result = base;

   // Дополнительно вращаем экран, чтобы получить 
   //   разрвернутую фигуру.
   mat3 rotViewHandle1 = rotateZ(0.5 * pi);
   vec3 offsetViewHandle1 = vec3(0.0, -1.0, 0.0);
   realpnt = rotViewHandle1 * m * p + offsetViewHandle1;
   float handle1 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);
   result = min(result, handle1);

   // Дополнительно вращаем экран, чтобы получить 
   //   разрвернутую фигуру.
   mat3 rotViewHandle2 = rotateZ(-0.5 * pi);
   vec3 offsetViewHandle2 = vec3(0.0, -1.0, 0.0);
   realpnt = rotViewHandle2 * m * p + offsetViewHandle2;
   float handle2 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);
   result = min(result, handle2);
   
   mat3 rotViewSoup = rotateX(pi);
   realpnt = rotViewSoup * m * p;
   // Заполняется снова за 5 секунд.
   float soup = sdCutSphere(realpnt, 1.0, max(0.0, sin(iTime * 2.0 * pi / 5.0)));
   if (soup < result) {
       clr = soupClr;
   } else {
       clr = cupClr;
   }
   result = min(result, soup);
   
   return result;
}


vec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out vec3 clr )
{
	vec3	p         = from;
	float	totalDist = 0.0;
	
	hit = false;
	
	for ( int steps = 0; steps < maxSteps; steps++ )
	{
		float	dist = sdf ( p, m, clr );
        
		if ( dist < 0.01 )
		{
			hit = true;
			break;
		}
		
		totalDist += dist;
		
		if ( totalDist > 10.0 )
			break;
			
		p += dist * dir;
	}
	
	return p;
}

vec3 generateNormal ( vec3 z, float d, in mat3 m )
{
    float e   = max (d * 0.5, eps );
    vec3 clr = vec3(0.0, 0.0, 0.0);
    float dx1 = sdf(z + vec3(e, 0, 0), m, clr);
    float dx2 = sdf(z - vec3(e, 0, 0), m, clr);
    float dy1 = sdf(z + vec3(0, e, 0), m, clr);
    float dy2 = sdf(z - vec3(0, e, 0), m, clr);
    float dz1 = sdf(z + vec3(0, 0, e), m, clr);
    float dz2 = sdf(z - vec3(0, 0, e), m, clr);
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

const float roughness = 0.2;
const vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );
const float gamma = 2.2;
const float FDiel = 0.04;		// Fresnel for dielectrics

vec3 fresnel ( in vec3 f0, in float product )
{
	product = clamp ( product, 0.0, 1.0 );		// saturate
	
	return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );
}

float D_blinn(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float n = 2.0 / m2 - 2.0;
    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);
}

float D_beckmann ( in float roughness, in float NdH )
{
	float m    = roughness * roughness;
	float m2   = m * m;
	float NdH2 = NdH * NdH;
	
	return exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);
}

float D_GGX ( in float roughness, in float NdH )
{
	float m  = roughness * roughness;
	float m2 = m * m;
	float NdH2 = NdH * NdH;
	float d  = (m2 - 1.0) * NdH2 + 1.0;
	
	return m2 / (pi * d * d);
}

float G_schlick ( in float roughness, in float nv, in float nl )
{
    float k = roughness * roughness * 0.5;
    float V = nv * (1.0 - k) + k;
    float L = nl * (1.0 - k) + k;
	
    return 0.25 / (V * L);
}

float G_neumann ( in float nl, in float nv )
{
	return nl * nv / max ( nl, nv );
}

float G_klemen ( in float nl, in float nv, in float vh )
{
	return nl * nv / (vh * vh );
}

float G_default ( in float nl, in float nh, in float nv, in float vh )
{
	return min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );
}

vec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v, in vec3 clr )
{
    vec3  h    = normalize ( l + v );
	float nh   = dot (n, h);
	float nv   = dot (n, v);
	float nl   = dot (n, l);
	float vh   = dot (v, h);
    float metallness = 1.0;
    vec3  base  = pow ( clr, vec3 ( gamma ) );
    vec3  F0    = mix ( vec3(FDiel), clr, metallness );
	
			// compute Beckman
   	float d = D_beckmann ( roughness, nh );

            // compute Fresnel
    vec3 f = fresnel ( F0, nv );
	
            // default G
    float g = G_default ( nl, nh, nv, vh );
	
			// resulting color
	vec3  ct   = f*(0.25 * d * g / nv);
	vec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;
	float ks   = 0.5;

	return vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

        // Normalized pixel coordinates (from 0 to 1)
    bool hit;
	//vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);
    // Повернем кружку дном вниз. Просто добавим к mouse.x так,
    //   чтобы картинка повернулась по y на pi.
    //   Поведение прокрутки не изменится, почти все значения
    //   синуса все так же будут пробегаться (все бы, почти все,
    //   пробегались, если бы была формула pi * mouse.y).
    //mouse.y += pi / 6.0; // Повернем кружку дном вниз :)
    vec3 mouse = vec3(sin(iTime) / 2.0, -0.4, 0);
    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);
    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;
     vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );
	vec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );
    vec4 color = vec4 ( 0, 0, 0, 1 );
    
    vec3 clr = vec3(0, 0, 0);
    vec3 p     = trace ( eye, dir, hit, m, clr );


	if ( hit )
	{
		vec3  l  = normalize        ( light - p );
        vec3  v  = normalize        ( eye - p );
		vec3  n  = generateNormal   ( p, 0.001, m );
		float nl = max ( 0.0, dot ( n, l ) );
        vec3  h  = normalize ( l + v );
        float hn = max ( 0.0, dot ( h, n ) );
        float sp = pow ( hn, 150.0 );
		
        color = cookTorrance ( p, n, l, v, clr );
	} 

        // Output to screen
    fragColor = color * 3.0;
}


void main()
{
  iResolution = vec2(parameters.iResolution_x, parameters.iResolution_y);
  iTime = parameters.time;

  vec4 fragColor;
  vec2  fragCoord  = vec2(gl_GlobalInvocationID.xy);
  ivec2 iFragCoord = ivec2(gl_GlobalInvocationID.xy);
  mainImage(fragColor, fragCoord);

  if (iFragCoord.x < 1280 && iFragCoord.y < 720)
    imageStore(resultImage, iFragCoord, fragColor);
}
